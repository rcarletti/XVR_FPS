#define MAX_LIFE   3

class bullet
{
	var id;
	var position;
	var prevPosition;
	var direction;
	var speed;
	var bulletMesh;
	var bulletObj;
	var life;
	var isFlying;
	var color;
	var collisionPoints;
	
	init(id, col, vel);
	shoot(pos,dir);
	update(level, deltaFrame, radius);
	draw();
};



function bullet::init(id, col, speed)
{
	bulletMesh = CVMNewMesh(VRP_SPHERE);
	bulletMesh.Scale(0.1);
	bulletObj = CVmObj(bulletMesh);
	this.id = id;
	this.speed = speed;
	life = 0;
	prevPosition = position = [0.0, 0.0, 0.0];
	direction = [0.0, 0.0, 0.0];
	color = col;
	bulletMesh.ModulateMaterials(color);
	collisionPoints = Array(8);
	for(var i = 0; i < len(collisionPoints); i++) {
		collisionPoints[i] = Array(3);
	}
}

function bullet::shoot(pos, dir) {
	prevPosition = position = pos;
	direction = dir;
	life = MAX_LIFE;
	return 1;
}

function bullet::draw() {
	bulletObj.Draw();
}

function bullet::update(level, deltaFrame, radius) {
	prevPosition = position;
	position += direction * speed * deltaFrame;

	collisionPoints[0] = position - [0, radius, 0];
	collisionPoints[1] = position + [0, radius, 0];
	collisionPoints[2] = position + VectorRotate(90, [0,1,0], direction.x_z) * radius;
	collisionPoints[3] = position + VectorRotate(-90, [0,1,0], direction.x_z) * radius;
	collisionPoints[4] = prevPosition - [0, radius, 0];
	collisionPoints[5] = prevPosition + [0, radius, 0];
	collisionPoints[6] = prevPosition + VectorRotate(90, [0,1,0], direction.x_z) * radius;
	collisionPoints[7] = prevPosition + VectorRotate(-90, [0,1,0], direction.x_z) * radius;

	if(level.map.IsColliding(collisionPoints[0][0],collisionPoints[0][1])){
		life = 0;
	}
	else{
		bulletObj.SetPosition(position);
		life-= deltaFrame;	
	}

}

