SET CAMERA_FOV  = 60;
SET CAMERA_NEAR = 0.3;
SET CAMERA_FAR  = 300;
SET CAMERA_HEIGHT = 1.5;
SET AMMOS_INTERVAL = 30000;
SET HEALTH_INTERVAL = 15000;
SET SCORE_TIMER = 1000;
SET HEADSHOT_TIMER = 1000;
SET SPAWN_TIME = 5000;

#include "weapon.s3d"
#include "healthPickups.s3d"

function distance(x1, x2, y1, y2){
	var dx = x1 - x2;
	var dy = y1 - y2;
	var dist = sqrt(dx * dx + dy * dy);
	return dist;
}

class scenario 
{	
	//variables
	var map;

	var skyMesh;
	var skyObj;
	var skyMaterial;
	var skyTexture;

	var rows;
	var columns;
	
	var ammos;
	var ammosNum;
	var ammosTimer;
	var camera;
	var isFirstPersonCamera;
	var myPlayer;
	var enemies;
	var healthPickups;
	var healthTimer;
	var healthNum;
	var headshot;
	var scoreTimer;
	var headshotTimer;
	var killPktNum;
	var hitPktNum;
	var startTime;
	var sfxHeadshot;
	var hasKilled;
	var fragTimer;
	var killer;
	var fraggedID;
	var weaponSpawns;
	
	//functions
	init(textfile);	
	addplayer(col, id, level);
	update();
	draw();
	updateCamera();
	isColliding(pos, radius);
	isWeaponPresent(x, z);
	getWeaponType(x, z);
	pickUpAmmos(x, z);
	updateAmmos();
	addEnemy(e);
	checkPlayerCollision();
	isBulletColliding(b, e, radius);
	getEnemyById(ID);
	isHealthPackPresent(posx, posz);
	pickUpHealth(posx, posz);
	updateHealthPickUps();
	sendScores();
	updateEnemies();
	showScores();
};

//********************************************************************
//INIT SCENARIO
//********************************************************************

function scenario :: init(textfile){
	ammosNum = 0;
	healthNum = 0;
	headshot = false;
	headshotTimer = 0;
	hitPktNum = 0;
	killPktNum = 0;
	fraggedID = -1;
	hasKilled = false;
	fragTimer = 0;
	killer = -1;
	weaponSpawns = Array(4);
	
	foreach (var w in weaponSpawns) {
		w = Array(3);
	}
	
	weaponSpawns[0] = [1,0.3,10];
	weaponSpawns[1] = [20,1,40];
	weaponSpawns[2] = [50,1,20];
	weaponSpawns[3] = [35,1,4];
	var mapMesh = CVmNewMesh("military.aam");
	mapMesh.Scale(0.30);
	map = CVmObj(mapMesh);
			
	//set textures and stuff
	
	sfXHeadshot = CVmVrAWav("headshot.wav",true);

	/*sky */
	skyMaterial = CVmMaterial();
	skyTexture   = CVmTexture("sky_texture.png");
	skyMaterial.SetTexture(skyTexture);
	skyMesh = CVmNewMesh(VRP_SPHERE);
	skyMesh.FlipNormals(true);
	skyMesh.Scale(400);
	skyMesh.ForceMaterial(SkyMaterial);
	skyObj = CVmObj(SkyMesh);
	SkyMaterial.Diffuse = [1, 1, 1];
	SkyMaterial.Emission = [1, 1, 1];

	ammos = Array(0);
	enemies = Array(0);
	healthPickups = Array(0);

	healthTimer = array(healthNum);
	for (var i = 0; i < healthNum; i++) {
		healthTimer[i] = -1;
	}
	
	scoreTimer = 0;
	
	/* spawn ammos */
	for (var i = 0; i< 4; i++) {
		var tempW = (Rand(1) == 0)? weapon("railgun.aam") : weapon("rocketl.aam");
		tempW.setSpawnPoint([weaponSpawns[i][0], weaponSpawns[i][1], weaponSpawns[i][2]]);
		aadd(ammos, {tempW, [weaponSpawns[i][0], weaponSpawns[i][1], weaponSpawns[i][2]], tempW.name, true} );
		ammosNum++;
	}
	
	
	ammosTimer = array(ammosNum);
	for (var i = 0; i < ammosNum; i++) {
		ammosTimer[i] = -1;
	}
	
	
	/*init camera */		
	camera = CameraGetCurrent();		
	isFirstPersonCamera = true;
	camera.SetFovY(CAMERA_FOV);
	camera.SetZNear(CAMERA_NEAR);
	camera.SetZFar(CAMERA_FAR);
}

//********************************************************************
//DRAW
//********************************************************************

function scenario :: draw()
{
	map.Draw();
	skyObj.Draw();

	foreach (var e in enemies) {
		if(!e.isDead)
			e.draw();
	}

	myPlayer.Draw();	
		
	foreach (var a in ammos){
		if(a[3]) {
			a[0].draw();
		}
	} 
	foreach (var h in healthPickups) {
		if(h[2]) {
			h[0].draw();
		}
	}

	if(headshot) {
		ConsoleFont("Tahoma", 30);
		ConsoleColor([1, 1, 1]);
		ConsoleText(0.28, 0.8 , "HEADSHOT +20" );
	}
	
	if(hasKilled) {
		ConsoleFont("Tahoma", 20);
		ConsoleColor([1, 1, 1]);
		ConsoleText(0.28, 0.7 , "YOU FRAGGED PLAYER " + str(fraggedID));
	}
	
	if(myPlayer.isDead) {
	 	ConsoleColor([1,1,1]);
		ConsoleFont("Arial", 25);
		ConsoleText(0.22,0.8, "FRAGGED BY PLAYER " + str(killer));
		showScores();
		if(getTime() - myPlayer.deathTimer > SPAWN_TIME) {
			myPlayer.isDead = false;
			myPlayer.spawn();
		}
	 }
	
}

//********************************************************************
//ADD ONE PLAYER
//********************************************************************

function scenario :: addPlayer(id, col, level){
	if (col == VOID) {
		col = [rand(255)/255.0,rand(255)/255.0,rand(255)/255.0];
	}
	var tmpPlayer = player();

	tmpPlayer.init(id,col,[0,0,0]);

	return tmpPlayer;
}

//********************************************************************
//ADD ONE ENEMY
//********************************************************************
function scenario :: addEnemy(e) {
	aadd(enemies, e);
	e.local = false;
}

//********************************************************************
//UPDATE SCENARIO
//********************************************************************

function scenario :: update(){
	var loop = true;
	while (loop) {
		var data = networkReceive();
		if (data!= null) {
			if (data[1] != myPlayer.ID) {
				/*heartbeat PDU */
				if (data[0] == HEARTBEAT_PDU) {
					var e = getEnemyById(data[1]);
					if (e == void) {		/*new enemy */
						var tmpEnemy = addPlayer(data[1], [data[2],data[3], data[4]], this);	
						addEnemy(tmpEnemy);
						e = getEnemyById(data[1]);		
					}
					e.heartbeatTimer = getTime();
					e.expectedHitPkt = data[5];
					e.expectedKillPkt = data[6];
				}
				
				/*data PDU */
				else if (data[0] == DATA_PDU) {
					var e = getEnemyById(data[1]);
					if(e!= null){
					e.position = [data[2], data[3], data[4]];
					e.walkDirection = [data[5], data[6], data[7]];
					e.angleX = data[8];
					e.angleY = data[9];
					if (data[10] != e.currWeapon) {
						e.swapWeapon(data[10]);
					}
					e.health = data[11];
					e.currentFrame = data[12];
					if (data[13] == 1) {
						e.isWalking = true;
						e.speedMultiplier = data[13];
					}
					else if(data[13] == 2) {
						e.isWalking = true;
						e.speedMultiplier = data[13];
					}
					else if(data[13] == 0) {
						e.isWalking = false;
						e.isRunning = false;
					}
					e.isDead = data[14];
				}

				}
				
				/*bullets PDU */
				else if (data[0] == BULLETS_PDU) {
					var e = getEnemyById(data[1]);
					if(e!= null){
						var bLen = (len(data) - 2) / 8;
						asize (e.bullets, bLen);
						e.bulletNum = bLen;
						for (var i = 2, j = 0; i < (bLen * 8); i+= 8, j++) {
							var tmpB = bullet();
							tmpB.init(e.color, data[i + 6]);
							tmpB.position = [data[i + 0], data[i + 1], data[i + 2]];
							tmpB.direction = [data[i + 3], data[i + 4], data[i + 5]];
							tmpB.life = data[i + 7];
							e.bullets[j] = tmpB;
						}
					}
				}
				
				/*hit PDU */
				else if (data[0] == HIT_PDU) {
					if (data[2] == myPlayer.ID) {
						/*hit someone*/          
						var e = getEnemyById(data[1]);
						if(data[3] >= e.expectedHitPkt) {
							e.expectedHitPkt = data[3] + 1;
							e.hitPlayer();
						}
					}					
				}
				
				/*kill PDU */
				else if (data[0] == KILL_PDU) {
					var e = getEnemyById(data[1]);
					if(data[2] == myPlayer.ID) {
						if(data[4] >= e.expectedKillPkt){
							hasKilled = true;
							fragTimer = getTime();
							fraggedID = data[1];
							e.expectedKillPkt = data[4] + 1;
							e.hitLenght = 0;
							if(data[3]){
								myPlayer.score += 20;
								headshot = true;
								headshotTimer = getTime();
								sfxHeadshot.Play();
							}
							else myPlayer.score += 10;
						}
					}
				}
				
				else if (data[0] == DISCONNECT_PDU) {
					for(var i = 0; i < len(enemies); i++) {
						if(enemies[i].ID == data[1]) {
							adel(enemies, i);
						}
					}
				}
				
				else if (data[0] == SCORE_PDU) {

					for(var i = 1; i < len(data) - 1; i += 2) {
						var e = getEnemyById(data[i]);
						if(e != null && data[i + 1] > e.score) {
							e.score = data[i + 1];
						}
					}
				}
			}	
		}
		else {
			loop = false;
		}
	}
	
	if (KeyPressed("C")) {
		isFirstPersonCamera = false;
	}
	if (KeyPressed("X")) {
		isFirstPersonCamera = true;
	}
	if(keyPressed("P")) {
		//ShowCursor(TRUE);
	}
	
	sfxHeadshot.SetPosition(myPlayer.position);
	
	/*update players */

	myPlayer.update();
	
	foreach (var w in ammos) {
		w[0].update();
	}
	foreach (var h in healthPickups) {
		h[0].update();
	}
	
	updateEnemies();
	//foreach (var e in enemies) {
	//	e.update();
	//}
	
	if(getTime() - headshotTimer > HEADSHOT_TIMER) {
		headshot = false;
	}
	
	if(getTime() - fragTimer > HEADSHOT_TIMER) {
		hasKilled = false;
	}
		
	updateCamera();
	checkPlayerCollision();
	updateAmmos();
	updateHealthPickUps();

	if(getTime() - scoreTimer > SCORE_TIMER) {
		sendScores();
		scoreTimer = getTime();
	}

}


//********************************************************************
//UPDATE ENEMIES (DETECTS CRASH)
//********************************************************************

function scenario :: updateEnemies() {
	for (var i = 0; i < len(enemies); i++) {
		var e = enemies[i];
		if((getTime() - e.heartbeatTimer - startTime) > PLAYER_TIMEOUT) {
			adel(enemies,i);
			i--;
			Outputln("PLAYER CRASHED");
		}
		
		else {
			e.update();
		}
		
	}
}


//********************************************************************
//SEND SCORES
//********************************************************************

function scenario :: sendScores() {
	var PDU = Array((len(enemies) * 2) + 3);
	PDU[0] = SCORE_PDU;
	PDU[1] = myPlayer.ID;
	PDU[2] = myPlayer.score;
	var i = 3;
	foreach (var e in enemies) {
		PDU[i] = e.ID;
		PDU[i + 1] = e.score;
		i += 2;
	}

	networkSend(PDU);
}

//********************************************************************
//CHECK FOR BULLET-ENEMIES COLLISION
//********************************************************************

function scenario :: checkPlayerCollision() {
	
	foreach (var e in enemies) {
		foreach (var b in e.bullets) {
			var h = isBulletColliding(b, myPlayer, e.weapons[e.currWeapon].damageRadius);
			if (b.life!= 0 && h > 0) {
				b.life = 0;
				var PDU = Array(4);
				PDU[0] = HIT_PDU;
				PDU[1] = myPlayer.ID;
				PDU[2] = e.ID;
				PDU[3] = hitPktNum;
				for(var i = 0; i < 4; i++)
					networkSend(PDU);
				hitPktNum++;
				if(h > 1.1) {
					myPlayer.health = 0;
				}
				else 
					myPlayer.health -= e.weapons[e.currWeapon].damage;
				if(myPlayer.health <= 0) {
					myPlayer.health = 0;
					myPlayer.isDead = true;
					killer = e.ID;
					myPlayer.deathTimer = getTime();
					var PDU = Array(5);
					PDU[0] = KILL_PDU;
					PDU[1] = myPlayer.ID;
					PDU[2] = e.ID;
					if(h > 1.1)
						PDU[3] = true;
					else PDU[3] = false;
					PDU[4] = killPktNum;
					for(var i = 0; i < 4; i++)
						networkSend(PDU);
					killPktNum++;
				}
			}
		}
	}
	
}

//********************************************************************
//BULLET COLLISION
//********************************************************************

function scenario :: isBulletColliding(b, e, radius) {
	if (b.position.x >= e.position.x - radius &&
	    b.position.x < e.position.x + radius &&
	    b.position.z >= e.position.z - radius &&
	    b.position.z < e.position.z + radius &&
	    b.position.y >= e.position.y + 1 - radius &&
	    b.position.y < e.position.y + 1 + radius &&
	    !e.isDead
		) {
			return  b.position.y;
		}
	else return -1;
}

//********************************************************************
//UPDATE AMMOS
//********************************************************************

function scenario :: updateAmmos() {
	for (var i = 0; i < ammosNum; i++) {
		if(ammosTimer[i] != -1){
			if(getTime() - ammosTimer[i] > AMMOS_INTERVAL){
				ammosTimer[i] = -1;
				ammos[i][3] = true;
			}
		}
	}
}

//********************************************************************
//UPDATE HEALTH PICKUPS
//********************************************************************

function scenario :: updateHealthPickUps() {
	for (var i = 0; i < healthNum; i++) {
		if(healthTimer[i] != -1){
			if(getTime() - healthTimer[i] > HEALTH_INTERVAL){
				healthTimer[i] = -1;
				healthPickups[i][2] = true;
			}
		}
	}
}

//********************************************************************
//UPDATE CAMERA
//********************************************************************

function scenario :: updateCamera(){

	var normal = VectorRotate(-90, [0, 1, 0], myPlayer.direction.x_z);
	var camPos = myPlayer.position + [0, 1, 0] +
			    VectorRotate(myPlayer.angleX, normal, [0, 0.5, 0]);

	camera.SetPosition(camPos);
	camera.SetDirection(myPlayer.direction);
	
	if(!isFirstPersonCamera){
		var camPos = camera.GetPosition();
		var camDir = camera.GetDirection();
		camPos += [0,0.25,0];
		camPos += VectorRotate(190, Camera.GetYAxis(), camDir) * 2;
		camera.SetPosition(camPos); 
	}
}

//********************************************************************
//CHECK COLLISION
//********************************************************************

function scenario :: isColliding(pos, radius){
	return false;
}

//********************************************************************
//CHECK IF THERE'S A WEAPON IN X,Z
//********************************************************************

function scenario :: isWeaponPresent(posx, posz){
	foreach (var a in ammos) {
		var ax = a[1].x;
		var az = a[1].z;
		if(distance(posx, ax, posz, az) < 0.5 && a[3]) {
			return a[2];
		}
	}
	return "";
}

//********************************************************************
//CHECK IF THERE'S A HEALTH PACK IN X,Z
//********************************************************************

function scenario :: isHealthPackPresent(posx, posz){
	foreach (var h in healthPickups) {
		var hx = h[1].x;
		var hz = h[1].z;
		if(distance(posx, hx, posz, hz) < 0.5 && h[2]) {
			return true;
		}
	}
	return false;
}

//********************************************************************
//PICK UP AMMOS
//********************************************************************

function scenario :: pickUpAmmos(posx, posz) {
	for(var i = 0; i < ammosNum; i++) {
		var ax = ammos[i][1].x;
		var az = ammos[i][1].z;
		if(distance(posx, ax, posz, az) < 0.5) {
			ammos[i][3] = false;
			ammosTimer[i] = getTime();
		}
	}
}
//********************************************************************
//PICK UP HEALTH PACKS
//********************************************************************

function scenario :: pickUpHealth(posx, posz) {
	for(var i = 0; i < len(healthPickups); i++) {
		var hx = healthPickups[i][1].x;
		var hz = healthPickups[i][1].z;
		if(distance(posx, hx, posz, hz) < 0.5) {
			healthPickups[i][2] = false;
			healthTimer[i] = getTime();
		}
	}
}

//********************************************************************
//GET ENEMY BY ID
//********************************************************************

function scenario :: getEnemyById(ID) {
	foreach ( var e in enemies )  {
		if (e.id == ID)
			return e;
	}
	
	return null;
}

function scenario :: showScores() {
	var x = 0.22;
	var y = 0.67;
	ConsoleFont("Arial", 25);
	ConsoleColor([1,0,0]);

	ConsoleText(x, y , "PLAYER: " + str(myPlayer.ID) + "   "+ "Score: " + str(myPlayer.score));
	ConsoleColor([1,1,1]);
	ConsoleWidth(3); 
	ConsoleLines([x, y - 0.01, x + 0.42, y - 0.01]);
	y-= 0.07;
	foreach (var e in enemies) {
		ConsoleText(x, y , "PLAYER: " + str(e.ID) + "   "+ "Score: " + str(e.score));
		ConsoleLines([x, y - 0.01, x + 0.42, y - 0.01]);
		y-= 0.07;
	}
}