SET CAMERA_FOV  = 60;
SET CAMERA_NEAR = 0.3;
SET CAMERA_FAR  = 300;
SET CAMERA_HEIGHT = 1.5;

#include "weapon.s3d"

function distance(x1, x2, y1, y2){
	var dx = x1 - x2;
	var dy = y1 - y2;
	var dist = sqrt(dx * dx + dy * dy);
	return dist;
}

class scenario 
{	
	//variables
	var floorMesh;
	var floorObj;
	var floorMat;
	var floorTexture;
	
	var wallMesh;
	var wallObjArray;
	var wallMaterial;
	var wallTexture;
	
	var skyMesh;
	var skyObj;
	var skyMaterial;
	var skyTexture;
	
	var levelMatrix;
	var rows;
	var columns;
	
	var weaponsPos;
	var weapons;
	//array di giocatori
	var playerArray;
	//numero di giocatori presenti
	var playerNumber;
	var camera;
	var isFirstPersonCamera;
	
	//functions
	init(textfile);	
	addplayer(col);
	update();
	draw();
	updateCamera();
	isColliding(pos, radius);
};

//********************************************************************
//INIT SCENARIO
//********************************************************************

function scenario :: init(textfile){
	playerNumber = 0;
	playerArray = array(0);
	
	//load scenario
	if (!FileExist(textfile)) {
		trace(textfile);
	}
	var lines = LoadFile(textfile);
	rows = len(lines) ;
	columns = len(lines[0]);
	
	//create level matrix
	levelMatrix = array(rows);
	for (var i = 0; i < rows; i++){
		levelMatrix[i] = array(columns);
	}
	
	for (var i=0; i<rows; i++)
		for (var j=0; j<columns; j++)
			levelMatrix[i][j] = 0;
			
	//set textures and stuff
	
	/*floors */
	
	floorMat = CVmMaterial();
	floorTexture = CVmTexture("ground_texture.jpg");
	floorMat.SetTexture(floorTexture);
	floorMat.ChangeTextureParams(VR_U_TILING,10);
	floorMat.ChangeTextureParams(VR_V_TILING,10);
	floorMesh = CVmNewMesh(VRP_BOX);
	floorMesh.Scale(columns,1,rows);
	floorMesh.ForceMaterial(floorMat);	
	floorObj = CVmObj(floorMesh);
	floorObj.translate(0,-1,0);
	
	/*walls */
	
	
	wallTexture = CVmTexture("brick.jpg");
	
	/*sky */
	skyMaterial = CVmMaterial();
	skyTexture   = CVmTexture("sky_texture.jpg");
	skyMaterial.SetTexture(skyTexture);
	skyMesh = CVmNewMesh(VRP_SPHERE);
	skyMesh.FlipNormals(true);
	skyMesh.Scale(200);
	skyMesh.ForceMaterial(SkyMaterial);
	skyObj = CVmObj(SkyMesh);
	SkyMaterial.Diffuse = [1, 1, 1];
	
	wallObjArray = Array(0);
	weaponsPos = Array(0);
	weapons = Array(0);
	
	var i,j;
	
	for (i=0; i<rows; i++)
		for (j=0; j<columns; j++)
		{
			var height = val(lines[i][j]);
			if (height < 10 && height > 0)
			{
				levelMatrix[i][j] = height;
				wallMesh = CVmNewMesh(VRP_BOX);
				var tmpWall = CVmObj(wallMesh);
				wallMaterial = CVmMaterial();
				wallMaterial.Diffuse = [1, 1, 1];
				wallMaterial.SetTexture(wallTexture);
				wallMaterial.ChangeTextureParams(VR_V_TILING, height);
				wallMesh.Scale(1, height, 1);
				wallMesh.ForceMaterial(wallMaterial);
				tmpWall.SetPosition(j,0,i);
				aadd(wallObjArray,tmpWall);				
			}
			else if(lines[i][j] == "w"){
				var tempW = (Rand(1) == 0)? weapon("railgun.aam") : weapon("rocketl.aam");
				tempW.setSpawnPoint([j, 0.2, i]);
				levelMatrix[i][j] = (tempW.name == "railgun.aam") ? "r" : "rl";
				aadd(weapons, {tempW, [j, 0, i], tempW.name} );
			}
		}
	
	/*init camera */		
	camera = CameraGetCurrent();		
	isFirstPersonCamera = true;
	camera.SetFovY(CAMERA_FOV);
	camera.SetZNear(CAMERA_NEAR);
	camera.SetZFar(CAMERA_FAR);
}

//********************************************************************
//DRAW
//********************************************************************

function scenario :: draw()
{
	floorObj.Draw();
	
	var i;
	for (i = 0;i < len(wallObjArray); i++)
		wallObjArray[i].Draw();
		
	for (i = 0;i < playerNumber; i++)
		playerArray[i].Draw();	
		
	foreach (var p in weapons){
		p[0].draw();
	} 
		
	skyObj.Draw();
}

//********************************************************************
//ADD ONE PLAYER
//********************************************************************

function scenario :: addPlayer(col){
	if (col == VOID) {
		col = [rand(255)/255.0,rand(255)/255.0,rand(255)/255.0];
	}
	
	var tmpPlayer = player();
	var pos, posx, posz;
	/*spawn outside walls */
	do {		
		posx = rand(columns - 1);
		trace(posx);
		posz = rand(rows - 1);
		trace(posz);
		pos = [posx, 0, posz];
	}
	while(levelMatrix[posz][posx] > 1);
	
	tmpPlayer.init(playerNumber,col,pos, this);
	aadd(playerArray, tmpPlayer);
	playerNumber++;
}

//********************************************************************
//UPDATE SCENARIO
//********************************************************************

function scenario :: update(){
	
	if (KeyPressed("C")) {
		isFirstPersonCamera = false;
	}
	if (KeyPressed("X")) {
		isFirstPersonCamera = true;
	}
	if(keyPressed("P")) {
		//ShowCursor(TRUE);
	}
	
	/*update players */
	for (var i = 0; i < playerNumber; i++){
		playerArray[i].update();
	}
	
	foreach (var w in weapons){
		w[0].update();
	}
	
	updateCamera();
	
	//do some other stuff
}

//********************************************************************
//UPDATE CAMERA
//********************************************************************

function scenario :: updateCamera(){

	var normal = VectorRotate(-90, [0, 1, 0], playerArray[0].direction.x_z);
	var camPos = playerArray[0].position + [0, 1, 0] +
			    VectorRotate(playerArray[0].angleX, normal, [0, 0.5, 0]);

	camera.SetPosition(camPos);
	camera.SetDirection(playerArray[0].direction);
	//camera.RotateLocal(-playerArray[0].angleX, [1,0,0]);
	
	if(!isFirstPersonCamera){
		var camPos = camera.GetPosition();
		var camDir = camera.GetDirection();
		camPos += [0,0.25,0];
		camPos += VectorRotate(190, Camera.GetYAxis(), camDir) * 2;
		camera.SetPosition(camPos); 
	}
}

function scenario :: isColliding(pos, radius){
	var tempWalls = array(0);
	foreach (var w in wallObjarray){
		var wPos = w.GetPosition();
		if(distance((wPos.x + 0.5),pos.x, (wPos.z + 0.5), pos.z) < radius){
			aadd(tempWalls, w);
		}
	}
	if (len(tempWalls) > 0)
		return true;
	else 
		return false;
}
