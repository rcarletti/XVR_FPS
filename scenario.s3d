SET CAMERA_FOV  = 60;
SET CAMERA_NEAR = 0.3;
SET CAMERA_FAR  = 300;
SET CAMERA_HEIGHT = 1.5;
SET AMMOS_INTERVAL = 30000;
SET HEALTH_INTERVAL = 15000;

#include "weapon.s3d"
#include "healthPickups.s3d"

function distance(x1, x2, y1, y2){
	var dx = x1 - x2;
	var dy = y1 - y2;
	var dist = sqrt(dx * dx + dy * dy);
	return dist;
}

class scenario 
{	
	//variables
	var floorMesh;
	var floorObj;
	var floorMat;
	var floorTexture;
	
	var wallMesh;
	var wallObjArray;
	var wallMaterial;
	var wallTexture;
	
	var skyMesh;
	var skyObj;
	var skyMaterial;
	var skyTexture;
	
	var levelMatrix;
	var rows;
	var columns;
	
	var ammos;
	var ammosNum;
	var ammosTimer;
	var camera;
	var isFirstPersonCamera;
	var myPlayer;
	var enemies;
	var healthPickups;
	var healthTimer;
	var healthNum;
	
	//functions
	init(textfile);	
	addplayer(col, id, level);
	update();
	draw();
	updateCamera();
	isColliding(pos, radius);
	isWeaponPresent(x, z);
	getWeaponType(x, z);
	pickUpAmmos(x, z);
	updateAmmos();
	addEnemy(e);
	checkPlayerCollision();
	isBulletColliding(b, e, radius);
	getEnemyById(ID);
	isHealthPackPresent(posx, posz);
	pickUpHealth(posx, posz);
	updateHealthPickUps();
};

//********************************************************************
//INIT SCENARIO
//********************************************************************

function scenario :: init(textfile){
	ammosNum = 0;
	healthNum = 0;
	
	//load scenario
	if (!FileExist(textfile)) {
		trace(textfile);
	}
	var lines = LoadFile(textfile);
	rows = len(lines) ;
	columns = len(lines[0]);
	
	//create level matrix
	levelMatrix = array(rows);
	for (var i = 0; i < rows; i++){
		levelMatrix[i] = array(columns);
	}
	
	for (var i=0; i<rows; i++)
		for (var j=0; j<columns; j++)
			levelMatrix[i][j] = 0;
			
	//set textures and stuff
	
	/*floors */
	
	floorMat = CVmMaterial();
	floorTexture = CVmTexture("ground_texture.jpg");
	floorMat.SetTexture(floorTexture);
	floorMat.ChangeTextureParams(VR_U_TILING,10);
	floorMat.ChangeTextureParams(VR_V_TILING,10);
	floorMesh = CVmNewMesh(VRP_BOX);
	floorMesh.Scale(columns,1,rows);
	floorMesh.ForceMaterial(floorMat);	
	floorObj = CVmObj(floorMesh);
	floorObj.translate(0,-1,0);
	
	/*walls */
	wallTexture = CVmTexture("brick.jpg");
	
	/*sky */
	skyMaterial = CVmMaterial();
	skyTexture   = CVmTexture("sky_texture.jpg");
	skyMaterial.SetTexture(skyTexture);
	skyMesh = CVmNewMesh(VRP_SPHERE);
	skyMesh.FlipNormals(true);
	skyMesh.Scale(200);
	skyMesh.ForceMaterial(SkyMaterial);
	skyObj = CVmObj(SkyMesh);
	SkyMaterial.Diffuse = [1, 1, 1];
	
	wallObjArray = Array(0);
	ammos = Array(0);
	enemies = Array(0);
	healthPickups = Array(0);
	
	var i,j;
	/*parse level */
	for (i=0; i<rows; i++)
		for (j=0; j<columns; j++)
		{
			var height = val(lines[i][j]);
			if (height < 10 && height > 0) {
				levelMatrix[i][j] = height / 2;
				wallMesh = CVmNewMesh(VRP_BOX);
				var tmpWall = CVmObj(wallMesh);
				wallMaterial = CVmMaterial();
				wallMaterial.Diffuse = [1, 1, 1];
				wallMaterial.SetTexture(wallTexture);
				wallMaterial.ChangeTextureParams(VR_V_TILING, height / 2);
				wallMesh.Scale(1, height / 2 , 1);
				wallMesh.ForceMaterial(wallMaterial);
				tmpWall.SetPosition(j,0,i);
				aadd(wallObjArray,tmpWall);				
			}
			else if(lines[i][j] == "w") {
				var tempW = (Rand(1) == 0)? weapon("railgun.aam") : weapon("rocketl.aam");
				tempW.setSpawnPoint([j, 0.2, i]);
				aadd(ammos, {tempW, [j, 0, i], tempW.name, true} );
				ammosNum++;
			}
			else if(lines[i][j] == "h") {
				var tempH = healthPickup();
				tempH.setSpawnPoint([j, 1, i]);
				aadd(healthPickups, {tempH, [j, 0, i], true});
				healthNum++;
			}
		}
		
	ammosTimer = array(ammosNum);
	for (var i = 0; i < ammosNum; i++) {
		ammosTimer[i] = -1;
	}
	
	healthTimer = array(healthNum);
	for (i = 0; i < healthNum; i++) {
		healthTimer[i] = -1;
	}
	
	
	/*init camera */		
	camera = CameraGetCurrent();		
	isFirstPersonCamera = true;
	camera.SetFovY(CAMERA_FOV);
	camera.SetZNear(CAMERA_NEAR);
	camera.SetZFar(CAMERA_FAR);
}

//********************************************************************
//DRAW
//********************************************************************

function scenario :: draw()
{
	floorObj.Draw();
	
	var i;
	for (i = 0;i < len(wallObjArray); i++)
		wallObjArray[i].Draw();
		
	foreach (var e in enemies) {
		e.draw();
	}
	myPlayer.Draw();	
		
	foreach (var a in ammos){
		if(a[3]) {
			a[0].draw();
		}
	} 
	foreach (var h in healthPickups) {
		if(h[2]) {
			h[0].draw();
		}
	}
		
	skyObj.Draw();
}

//********************************************************************
//ADD ONE PLAYER
//********************************************************************

function scenario :: addPlayer(id, col, level){
	if (col == VOID) {
		col = [rand(255)/255.0,rand(255)/255.0,rand(255)/255.0];
	}
	var tmpPlayer = player();
	tmpPlayer.level = level;
	var pos, posx, posz;
	/*spawn outside walls */
	do {		
		posx = rand(columns - 1);
		posz = rand(rows - 1);
		pos = [posx, 0, posz];
	}
	while(isColliding(pos, 0.8));
	
	tmpPlayer.init(id,col,pos);

	
	return tmpPlayer;
}

//********************************************************************
//ADD ONE ENEMY
//********************************************************************
function scenario :: addEnemy(e) {
	aadd(enemies, e);
	e.local = false;
}

//********************************************************************
//UPDATE SCENARIO
//********************************************************************

function scenario :: update(){
	
	var loop = true;
	while (loop) {
		var data = networkReceive();
		if (data!= null) {
			if (data[1] != myPlayer.ID) {
				/*heartbeat PDU */
				if (data[0] == HEARTBEAT_PDU) {
					var e = getEnemyById(data[1]);
					if (e == void) {		/*new enemy */
						var tmpEnemy = addPlayer(data[1], [data[2],data[3], data[4]], this);
						addEnemy(tmpEnemy);	
					}
				}
				
				/*data PDU */
				else if (data[0] == DATA_PDU) {
					var e = getEnemyById(data[1]);
					e.position = [data[2], data[3], data[4]];
					e.walkDirection = [data[5], data[6], data[7]];
					e.angleX = data[8];
					e.angleY = data[9];
					if (data[10] != e.currWeapon) {
						e.swapWeapon(data[10]);
					}
					e.health = data[11];
					e.currentFrame = data[12];
					if (data[13] == 1) {
						e.isWalking = true;
						e.speedMultiplier = data[13];
					}
					else if(data[13] == 2) {
						e.isWalking = true;
						e.speedMultiplier = data[13];
					}
					else if(data[13] == 0) {
						e.isWalking = false;
						e.isRunning = false;
					}

				}
				
				/*bullets PDU */
				else if (data[0] == BULLETS_PDU) {
					var e = getEnemyById(data[1]);
					var bLen = (len(data) - 2) / 8;
					asize (e.bullets, bLen);
					for (var i = 2, j = 0; i < (bLen * 8); i+= 8, j++) {
						var tmpB = bullet();
						tmpB.init(e.color, data[i + 6]);
						var position = [data[i + 0], data[i + 1], data[i + 2]];
						tmpB.direction = [data[i + 3], data[i + 4], data[i + 5]];
						tmpB.life = data[i + 7];
						tmpB.bulletObj.SetPosition(position);
						e.bullets[j] = tmpB;
					}
				}
				
				/*hit PDU */
				else if (data[0] == HIT_PDU) {
					trace(data);
					if (data[2] == myPlayer.ID) {
						/*damage*/
						Outputln("i'm hurt");
						myPlayer.health -= data[3];
						myPlayer.hitPlayer();
						if(myPlayer.health <= 0) {
							myPlayer.spawn();
							var PDU = Array(3);
							PDU[0] = KILL_PDU;
							PDU[1] = myPlayer.ID;
							PDU[2] = data[1];
							Outputln("sending kill pdu");
							trace(PDU);
							networkSend(PDU);
						}					
					}
				}
				/*kill PDU */
				else if (data[0] == KILL_PDU) {
					Outputln("receiving kill pdu from "+ str(data[1]));
					if(data[2] == myPlayer.ID) {
						myPlayer.score += 10;
						Outputln("killed someone");
					}
				}
				
				else if(data[0] == DISCONNECT_PDU) {
					trace(data);
					for(var i = 0; i < len(enemies); i++) {
						if(enemies[i].ID == data[1]) {
							adel(enemies, i);
						}
					}
				}
			}	
		}
		else {
			loop = false;
		}
	}
	
	if (KeyPressed("C")) {
		isFirstPersonCamera = false;
	}
	if (KeyPressed("X")) {
		isFirstPersonCamera = true;
	}
	if(keyPressed("P")) {
		//ShowCursor(TRUE);
	}
	
	/*update players */

	myPlayer.update();
	
	foreach (var w in ammos) {
		w[0].update();
	}
	foreach (var h in healthPickups) {
		h[0].update();
	}
	foreach (var e in enemies) {
		e.update();
	}
	
	updateCamera();
	checkPlayerCollision();
	updateAmmos();
	updateHealthPickUps();
	
	//do some other stuff
}

//********************************************************************
//CHECK FOR BULLET-ENEMIES COLLISION
//********************************************************************

function scenario :: checkPlayerCollision() {
	foreach (var b in myPlayer.bullets) {
		foreach (var e in enemies) {
			if(b.life!= 0 && isBulletColliding(b, e, myPlayer.weapons[myPlayer.currWeapon].damageRadius)) {
				e.hitPlayer();
				b.life = 0;
				var PDU = Array(4);
				PDU[0] = HIT_PDU;
				PDU[1] = myPlayer.ID;
				PDU[2] = e.ID;
				PDU[3] = myPlayer.weapons[e.currWeapon].damage;
				
				networkSend(PDU);
			}
		}
	}
}

//********************************************************************
//BULLET COLLISION
//********************************************************************

function scenario :: isBulletColliding(b, e, radius) {
	if (b.position.x >= e.position.x - radius &&
	    b.position.x <= e.position.x + radius &&
	    b.position.z >= e.position.z - radius &&
	    b.position.z <= e.position.z + radius 
		) {
			return true;
		}
	else return false;
}

//********************************************************************
//UPDATE AMMOS
//********************************************************************

function scenario :: updateAmmos() {
	for (var i = 0; i < ammosNum; i++) {
		if(ammosTimer[i] != -1){
			if(getTime() - ammosTimer[i] > AMMOS_INTERVAL){
				ammosTimer[i] = -1;
				ammos[i][3] = true;
			}
		}
	}
}

//********************************************************************
//UPDATE AMMOS
//********************************************************************

function scenario :: updateHealthPickUps() {
	for (var i = 0; i < healthNum; i++) {
		if(healthTimer[i] != -1){
			if(getTime() - healthTimer[i] > HEALTH_INTERVAL){
				healthTimer[i] = -1;
				healthPickups[i][2] = true;
			}
		}
	}
}

//********************************************************************
//UPDATE CAMERA
//********************************************************************

function scenario :: updateCamera(){

	var normal = VectorRotate(-90, [0, 1, 0], myPlayer.direction.x_z);
	var camPos = myPlayer.position + [0, 1, 0] +
			    VectorRotate(myPlayer.angleX, normal, [0, 0.5, 0]);

	camera.SetPosition(camPos);
	camera.SetDirection(myPlayer.direction);
	
	if(!isFirstPersonCamera){
		var camPos = camera.GetPosition();
		var camDir = camera.GetDirection();
		camPos += [0,0.25,0];
		camPos += VectorRotate(190, Camera.GetYAxis(), camDir) * 2;
		camera.SetPosition(camPos); 
	}
}

//********************************************************************
//CHECK COLLISION
//********************************************************************

function scenario :: isColliding(pos, radius){
	var tempWalls = array(0);
	foreach (var w in wallObjarray){
		var wPos = w.GetPosition();
		if(distance((wPos.x + 0.5),pos.x, (wPos.z + 0.5), pos.z) < radius && levelMatrix[wPos.z][wPos.x] > (pos.y + 0.5)){
			aadd(tempWalls, w);
		}
	}
	if (len(tempWalls) > 0)
		return true;
	else 
		return false;
}

//********************************************************************
//CHECK IF THERE'S A WEAPON IN X,Z
//********************************************************************

function scenario :: isWeaponPresent(posx, posz){
	foreach (var a in ammos) {
		var ax = a[1].x;
		var az = a[1].z;
		if(distance(posx, ax, posz, az) < 0.5 && a[3]) {
			return a[2];
		}
	}
	return "";
}

//********************************************************************
//CHECK IF THERE'S A HEALTH PACK IN X,Z
//********************************************************************

function scenario :: isHealthPackPresent(posx, posz){
	foreach (var h in healthPickups) {
		var hx = h[1].x;
		var hz = h[1].z;
		if(distance(posx, hx, posz, hz) < 0.5 && h[2]) {
			return true;
		}
	}
	return false;
}

//********************************************************************
//PICK UP AMMOS
//********************************************************************

function scenario :: pickUpAmmos(posx, posz) {
	for(var i = 0; i < ammosNum; i++) {
		var ax = ammos[i][1].x;
		var az = ammos[i][1].z;
		if(distance(posx, ax, posz, az) < 0.5) {
			ammos[i][3] = false;
			ammosTimer[i] = getTime();
		}
	}
}
//********************************************************************
//PICK UP HEALTH PACKS
//********************************************************************

function scenario :: pickUpHealth(posx, posz) {
	for(var i = 0; i < len(healthPickups); i++) {
		var hx = healthPickups[i][1].x;
		var hz = healthPickups[i][1].z;
		if(distance(posx, hx, posz, hz) < 0.5) {
			healthPickups[i][2] = false;
			healthTimer[i] = getTime();
		}
	}
}

function scenario :: getEnemyById(ID) {
	foreach ( var e in enemies )  {
		if (e.id == ID)
			return e;
	}
	
	return null;
}

