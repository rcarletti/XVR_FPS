SET CAMERA_FOV  = 60;
SET CAMERA_NEAR = 0.3;
SET CAMERA_FAR  = 300;
SET CAMERA_HEIGHT = 1.5;
SET AMMOS_INTERVAL = 30000;
SET HEALTH_INTERVAL = 15000;
SET SCORE_TIMER = 1000;
SET HEADSHOT_TIMER = 1000;
SET SPAWN_TIME = 5000;

#include "weapon.s3d"
#include "healthPickups.s3d"

function distance(x1, x2, y1, y2){
	var dx = x1 - x2;
	var dy = y1 - y2;
	var dist = sqrt(dx * dx + dy * dy);
	return dist;
}

class scenario 
{	
	/* graphics */
	var map;
	var skyMesh;
	var skyObj;
	var skyMaterial;
	var skyTexture;
	
	/* pickups */
	var ammos;
	var ammosNum;
	var healthPickups;
	var healthNum;
	var weaponSpawns;
	var healthSpawns;
	
	/* timers */	
	var ammosTimer;
	var healthTimer;
	var scoreTimer;
	var headshotTimer;
	var fragTimer;
	
	/* networking */
	var packetNumbers;
	
	/* player */
	var playerSpawns;
	var myPlayer;
	var headshot;
	var hasKilled;
	
	/* others */
	var camera;
	var isFirstPersonCamera;
	var enemies;
	var startTime;
	var sfxHeadshot;
	var killer;
	var fraggedID;
	
	//functions
	init(textfile);	
	addplayer(col, id, level);
	update();
	draw();
	updateCamera();
	isColliding(pos, radius);
	isWeaponPresent(x, z);
	getWeaponType(x, z);
	pickUpAmmos(x, z);
	updateAmmos();
	addEnemy(e);
	checkPlayerCollision();
	isBulletColliding(b, e, radius);
	getEnemyById(ID);
	isHealthPackPresent(posx, posz);
	pickUpHealth(posx, posz);
	updateHealthPickUps();
	sendScores();
	updateEnemies();
	showScores();
};

//********************************************************************
//INIT SCENARIO
//********************************************************************

function scenario :: init(textfile){
	
	/* pickups */
	ammosNum = 0;
	healthNum = 0;
	weaponSpawns = Array(5);
	healthSpawns = Array(2);
		
	foreach (var w in weaponSpawns) {
		w = Array(3);
	}
	
	foreach (var h in healthSpawns) {
		h = Array(3);
	}
	
	/* pickups positions */
	weaponSpawns[0] = [-13, 0.3, 32];
	weaponSpawns[1] = [-52, 0.3, 32];
	weaponSpawns[2] = [-14, 0.3, -24];
	weaponSpawns[3] = [52, 0.3, -31];
	weaponSpawns[4] = [42, 0.3, 7];
	
	healthSpawns[0] = [-40, 1, 13];
	healthSpawns[1] = [9, 1, -17];
	
	/* player */	
	headshot = false;
	hasKilled = false;
	playerSpawns = Array(4);
	playerSpawns[0] = [0, 0, 0];
	playerSpawns[1] = [-47, 0, -33];
	playerSpawns[2] = [41, 0, 32];
	playerSpawns[3] = [31, 0, -25];
	
	/* timers */
	
	headshotTimer = 0;
	fraggedID = -1;

	fragTimer = 0;
	killer = -1;


	packetNumbers = Array(7);
	
	for (var i = 0; i < 7; i++) {
		packetNumbers[i] = 0;
	}

	


	var mapMesh = CVmNewMesh("military.aam");
	mapMesh.Scale(0.30);
	map = CVmObj(mapMesh);
			
	//set textures and stuff
	
	sfXHeadshot = CVmVrAWav("headshot.wav",true);

	/*sky */
	skyMaterial = CVmMaterial();
	skyTexture   = CVmTexture("sky_texture.png");
	skyMaterial.SetTexture(skyTexture);
	skyMesh = CVmNewMesh(VRP_SPHERE);
	skyMesh.FlipNormals(true);
	skyMesh.Scale(400);
	skyMesh.ForceMaterial(SkyMaterial);
	skyObj = CVmObj(SkyMesh);
	SkyMaterial.Diffuse = [1, 1, 1];
	SkyMaterial.Emission = [1, 1, 1];

	ammos = Array(0);
	enemies = Array(0);
	healthPickups = Array(0);
	
	scoreTimer = 0;
	
	/* spawn ammos */
	for (var i = 0; i< len(weaponSpawns); i++) {
		var tempW = (Rand(1) == 0)? weapon("railgun.aam") : weapon("rocketl.aam");
		tempW.setSpawnPoint(weaponSpawns[i]);
		aadd(ammos, {tempW, weaponSpawns[i], tempW.name, true} );
		ammosNum++;
	}
	
	for (var i = 0; i < len(healthSpawns); i++ ) {
		var tempH = healthPickup();
		tempH.setSpawnPoint(healthSpawns[i]);
		aadd(healthPickups, {tempH, healthSpawns[i], true});
		healthNum++;
	}
			
	
	
	ammosTimer = array(ammosNum);
	for (var i = 0; i < ammosNum; i++) {
		ammosTimer[i] = -1;
	}
	
	
	healthTimer = array(healthNum);
	for (var i = 0; i < healthNum; i++) {
		healthTimer[i] = -1;
	}
	
	
	/*init camera */		
	camera = CameraGetCurrent();		
	isFirstPersonCamera = true;
	camera.SetFovY(CAMERA_FOV);
	camera.SetZNear(CAMERA_NEAR);
	camera.SetZFar(CAMERA_FAR);
}

//********************************************************************
//DRAW
//********************************************************************

function scenario :: draw()
{
	map.Draw();
	skyObj.Draw();

	foreach (var e in enemies) {
		if(!e.isDead)
			e.draw();
	}

	myPlayer.Draw();	
		
	foreach (var a in ammos){
		if(a[3]) {
			a[0].draw();
		}
	} 
	
	foreach (var h in healthPickups) {
		if(h[2]) {
			h[0].draw();
		}
	}

	if(headshot) {
		ConsoleFont("Tahoma", 30);
		ConsoleColor([1, 1, 1]);
		ConsoleText(0.28, 0.8 , "HEADSHOT +20" );
	}
	
	if(hasKilled) {
		ConsoleFont("Tahoma", 20);
		ConsoleColor([1, 1, 1]);
		ConsoleText(0.28, 0.7 , "YOU FRAGGED PLAYER " + str(fraggedID));
	}
	
	if(myPlayer.isDead) {
	 	ConsoleColor([1,1,1]);
		ConsoleFont("Arial", 25);
		ConsoleText(0.22,0.8, "FRAGGED BY PLAYER " + str(killer));
		showScores();
		if(getTime() - myPlayer.deathTimer > SPAWN_TIME) {
			myPlayer.isDead = false;
			myPlayer.spawn();
		}
	 }
	
}

//********************************************************************
//ADD ONE PLAYER
//********************************************************************

function scenario :: addPlayer(id, col, level){
	if (col == VOID) {
		col = [rand(255)/255.0,rand(255)/255.0,rand(255)/255.0];
	}
	var tmpPlayer = player();
	tmpPlayer.level = level;
	var r = rand(3);
	tmpPlayer.init(id,col,playerSpawns[r]);

	return tmpPlayer;
}

//********************************************************************
//ADD ONE ENEMY
//********************************************************************
function scenario :: addEnemy(e) {
	aadd(enemies, e);
	e.local = false;
}

//********************************************************************
//UPDATE SCENARIO
//********************************************************************

function scenario :: update(){
	var loop = true;
	while (loop) {
		var data = networkReceive();
		if (data!= null) {
			if (data[1] != myPlayer.ID) {
				/*heartbeat PDU */
				if (data[0] == HEARTBEAT_PDU) {
					var e = getEnemyById(data[1]);
					if (e == void) {		/*new enemy */
						var tmpEnemy = addPlayer(data[1], [data[2],data[3], data[4]], this);	
						addEnemy(tmpEnemy);
						e = getEnemyById(data[1]);		
					}
					e.heartbeatTimer = getTime();
					e.expectedPackets = data[5];
				}
				
				/*data PDU */
				else if (data[0] == DATA_PDU) {
					var e = getEnemyById(data[1]);
					if(e!= null && data[15] >= e.expectedPackets[DATA_PDU]){
					e.position = [data[2], data[3], data[4]];
					e.walkDirection = [data[5], data[6], data[7]];
					e.angleX = data[8];
					e.angleY = data[9];
					if (data[10] != e.currWeapon) {
						e.swapWeapon(data[10]);
					}
					e.health = data[11];
					e.currentFrame = data[12];
					if (data[13] == 1) {
						e.isWalking = true;
						e.speedMultiplier = data[13];
					}
					else if(data[13] == 2) {
						e.isWalking = true;
						e.speedMultiplier = data[13];
					}
					else if(data[13] == 0) {
						e.isWalking = false;
						e.isRunning = false;
					}
					e.isDead = data[14];
					e.expectedPackets[DATA_PDU] = data[15] + 1;
				}

				}
				
				/*bullets PDU */
				else if (data[0] == BULLETS_PDU) {
					var e = getEnemyById(data[1]);
					if(e!= null && data[len(data) - 1] >= e.expectedPackets[BULLETS_PDU]){
						var bLen = (len(data) - 2) / 8;
						asize (e.bullets, bLen);
						e.bulletNum = bLen;
						for (var i = 2, j = 0; i < (bLen * 8); i+= 8, j++) {
							var tmpB = bullet();
							tmpB.init(e.color, data[i + 6]);
							tmpB.position = [data[i + 0], data[i + 1], data[i + 2]];
							tmpB.direction = [data[i + 3], data[i + 4], data[i + 5]];
							tmpB.life = data[i + 7];
							e.bullets[j] = tmpB;
							e.expectedPackets[BULLETS_PDU] = data[len(data) -1] + 1;
						}
					}
				}
				
				/*hit PDU */
				else if (data[0] == HIT_PDU) {
					if (data[2] == myPlayer.ID) {
						/*hit someone*/          
						var e = getEnemyById(data[1]);
						if(data[3] >= e.expectedPackets[HIT_PDU]) {
							e.expectedPackets[HIT_PDU] = data[3] + 1;
							e.hitPlayer();
						}
					}					
				}
				
				/*kill PDU */
				else if (data[0] == KILL_PDU) {
					var e = getEnemyById(data[1]);
					if(data[2] == myPlayer.ID) {
						if(data[4] >= e.expectedPackets[KILL_PDU]){
							hasKilled = true;
							fragTimer = getTime();
							fraggedID = data[1];
							e.expectedPackets[KILL_PDU] = data[4] + 1;
							e.hitLenght = 0;
							if(data[3]){
								myPlayer.score += 20;
								headshot = true;
								headshotTimer = getTime();
								sfxHeadshot.Play();
							}
							else myPlayer.score += 10;
						}
					}
				}
				
				else if (data[0] == DISCONNECT_PDU) {
					var e = getEnemyById(data[1]);
					if(data[2] >= e.expectedPackets[DISCONNECT_PDU]) {
						for(var i = 0; i < len(enemies); i++) {
							if(enemies[i].ID == data[1]) {
								adel(enemies, i);
							}
						}
					 e.expectedPackets[DISCONNECT_PDU] = data[2] + 1;
					}
				}
				
				else if (data[0] == SCORE_PDU) {
					var e = getEnemyById(data[1]);
					Outputln(str(e.ID));
					if(data[len(data) - 1] >= e.expectedPackets[SCORE_PDU]) {
						for(var i = 1; i < len(data) - 1; i += 2) {
							var e = getEnemyById(data[i]);
							if(e != null && data[i + 1] > e.score) {
								e.score = data[i + 1];
							}
						}
					e.expectedPackets[SCORE_PDU] = data[len(data) - 1] + 1;
					}
				}
			}	
		}
		else {
			loop = false;
		}
	}
	
	if (KeyPressed("C")) {
		isFirstPersonCamera = false;
	}
	if (KeyPressed("X")) {
		isFirstPersonCamera = true;
	}
	if(keyPressed("P")) {
		//ShowCursor(TRUE);
	}
	
	sfxHeadshot.SetPosition(myPlayer.position);
	
	/*update players */

	myPlayer.update();
	
	foreach (var w in ammos) {
		w[0].update();
	}
	foreach (var h in healthPickups) {
		h[0].update();
	}
	
	updateEnemies();
	//foreach (var e in enemies) {
	//	e.update();
	//}
	
	if(getTime() - headshotTimer > HEADSHOT_TIMER) {
		headshot = false;
	}
	
	if(getTime() - fragTimer > HEADSHOT_TIMER) {
		hasKilled = false;
	}
		
	updateCamera();
	checkPlayerCollision();
	updateAmmos();
	updateHealthPickUps();

	if(getTime() - scoreTimer > SCORE_TIMER) {
		sendScores();
		scoreTimer = getTime();
	}

}


//********************************************************************
//UPDATE ENEMIES (DETECTS CRASH)
//********************************************************************

function scenario :: updateEnemies() {
	for (var i = 0; i < len(enemies); i++) {
		var e = enemies[i];
		if((getTime() - e.heartbeatTimer - startTime) > PLAYER_TIMEOUT) {
			adel(enemies,i);
			i--;
			Outputln("PLAYER CRASHED");
		}
		
		else {
			e.update();
		}
		
	}
}


//********************************************************************
//SEND SCORES
//********************************************************************

function scenario :: sendScores() {
	var PDU = Array((len(enemies) * 2) + 3);
	PDU[0] = SCORE_PDU;
	PDU[1] = myPlayer.ID;
	PDU[2] = myPlayer.score;
	var i = 3;
	foreach (var e in enemies) {
		PDU[i] = e.ID;
		PDU[i + 1] = e.score;
		i += 2;
	}
	PDU[len(PDU) - 1] = packetNumbers[SCORE_PDU];
	trace(PDU);
	networkSend(PDU);
	packetNumbers[SCORE_PDU]++;
}

//********************************************************************
//CHECK FOR BULLET-ENEMIES COLLISION
//********************************************************************

function scenario :: checkPlayerCollision() {
	
	foreach (var e in enemies) {
		foreach (var b in e.bullets) {
			var h = isBulletColliding(b, myPlayer, e.weapons[e.currWeapon].damageRadius);
			if (b.life!= 0 && h > 0) {
				b.life = 0;
				var PDU = Array(4);
				PDU[0] = HIT_PDU;
				PDU[1] = myPlayer.ID;
				PDU[2] = e.ID;
				PDU[3] = packetNumbers[HIT_PDU];
				for(var i = 0; i < 4; i++)
					networkSend(PDU);
				packetNumbers[HIT_PDU]++;
				if(h > 1.1) {
					myPlayer.health = 0;
				}
				else 
					myPlayer.health -= e.weapons[e.currWeapon].damage;
				if(myPlayer.health <= 0) {
					myPlayer.health = 0;
					myPlayer.isDead = true;
					killer = e.ID;
					myPlayer.deathTimer = getTime();
					var PDU = Array(5);
					PDU[0] = KILL_PDU;
					PDU[1] = myPlayer.ID;
					PDU[2] = e.ID;
					if(h > 1.1)
						PDU[3] = true;
					else PDU[3] = false;
					PDU[4] = packetNumbers[KILL_PDU];
					for(var i = 0; i < 4; i++)
						networkSend(PDU);
					packetNumbers[KILL_PDU]++;
				}
			}
		}
	}
	
}

//********************************************************************
//BULLET COLLISION
//********************************************************************

function scenario :: isBulletColliding(b, e, radius) {
	if (b.position.x >= e.position.x - radius &&
	    b.position.x < e.position.x + radius &&
	    b.position.z >= e.position.z - radius &&
	    b.position.z < e.position.z + radius &&
	    b.position.y >= e.position.y + 1 - radius &&
	    b.position.y < e.position.y + 1 + radius &&
	    !e.isDead
		) {
			return  b.position.y;
		}
	else return -1;
}

//********************************************************************
//UPDATE AMMOS
//********************************************************************

function scenario :: updateAmmos() {
	for (var i = 0; i < ammosNum; i++) {
		if(ammosTimer[i] != -1){
			if(getTime() - ammosTimer[i] > AMMOS_INTERVAL){
				ammosTimer[i] = -1;
				ammos[i][3] = true;
			}
		}
	}
}

//********************************************************************
//UPDATE HEALTH PICKUPS
//********************************************************************

function scenario :: updateHealthPickUps() {
	for (var i = 0; i < healthNum; i++) {
		if(healthTimer[i] != -1){
			if(getTime() - healthTimer[i] > HEALTH_INTERVAL){
				healthTimer[i] = -1;
				healthPickups[i][2] = true;
			}
		}
	}
}

//********************************************************************
//UPDATE CAMERA
//********************************************************************

function scenario :: updateCamera(){

	var normal = VectorRotate(-90, [0, 1, 0], myPlayer.direction.x_z);
	var camPos = myPlayer.position + [0, 1, 0] +
			    VectorRotate(myPlayer.angleX, normal, [0, 0.5, 0]);

	camera.SetPosition(camPos);
	camera.SetDirection(myPlayer.direction);
	
	if(!isFirstPersonCamera){
		var camPos = camera.GetPosition();
		var camDir = camera.GetDirection();
		camPos += [0,0.25,0];
		camPos += VectorRotate(190, Camera.GetYAxis(), camDir) * 2;
		camera.SetPosition(camPos); 
	}
}

//********************************************************************
//CHECK COLLISION
//********************************************************************

function scenario :: isColliding(pos, radius){
	return false;
}

//********************************************************************
//CHECK IF THERE'S A WEAPON IN X,Z
//********************************************************************

function scenario :: isWeaponPresent(posx, posz){
	foreach (var a in ammos) {
		var ax = a[1].x;
		var az = a[1].z;
		if(distance(posx, ax, posz, az) < 0.5 && a[3]) {
			return a[2];
		}
	}
	return "";
}

//********************************************************************
//CHECK IF THERE'S A HEALTH PACK IN X,Z
//********************************************************************

function scenario :: isHealthPackPresent(posx, posz){
	foreach (var h in healthPickups) {
		var hx = h[1].x;
		var hz = h[1].z;
		if(distance(posx, hx, posz, hz) < 0.5 && h[2]) {
			return true;
		}
	}
	return false;
}

//********************************************************************
//PICK UP AMMOS
//********************************************************************

function scenario :: pickUpAmmos(posx, posz) {
	for(var i = 0; i < ammosNum; i++) {
		var ax = ammos[i][1].x;
		var az = ammos[i][1].z;
		if(distance(posx, ax, posz, az) < 0.5) {
			ammos[i][3] = false;
			ammosTimer[i] = getTime();
		}
	}
}
//********************************************************************
//PICK UP HEALTH PACKS
//********************************************************************

function scenario :: pickUpHealth(posx, posz) {
	for(var i = 0; i < len(healthPickups); i++) {
		var hx = healthPickups[i][1].x;
		var hz = healthPickups[i][1].z;
		if(distance(posx, hx, posz, hz) < 0.5) {
			healthPickups[i][2] = false;
			healthTimer[i] = getTime();
		}
	}
}

//********************************************************************
//GET ENEMY BY ID
//********************************************************************

function scenario :: getEnemyById(ID) {
	foreach ( var e in enemies )  {
		if (e.id == ID)
			return e;
	}
	
	return null;
}

function scenario :: showScores() {
	var x = 0.22;
	var y = 0.67;
	ConsoleFont("Arial", 25);
	ConsoleColor([1,0,0]);

	ConsoleText(x, y , "PLAYER: " + str(myPlayer.ID) + "   "+ "Score: " + str(myPlayer.score));
	ConsoleColor([1,1,1]);
	ConsoleWidth(3); 
	ConsoleLines([x, y - 0.01, x + 0.42, y - 0.01]);
	y-= 0.07;
	foreach (var e in enemies) {
		ConsoleText(x, y , "PLAYER: " + str(e.ID) + "   "+ "Score: " + str(e.score));
		ConsoleLines([x, y - 0.01, x + 0.42, y - 0.01]);
		y-= 0.07;
	}
}